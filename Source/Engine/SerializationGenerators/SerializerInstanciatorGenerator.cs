using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Duck.SerializationGenerators;

[Generator]
public class SerializerInstanciatorGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var enumTypes = context.SyntaxProvider
            .CreateSyntaxProvider(IsInterestingEnum, ResolveTypeOrNull)
            .Where(type => type is not null)
            .Collect();

        context.RegisterSourceOutput(enumTypes, GenerateCode);
    }

    private static void GenerateCode(SourceProductionContext context, ImmutableArray<ITypeSymbol?> enumerations)
    {
        if (enumerations.IsDefaultOrEmpty) {
            return;
        }

        var checkBuilder = new StringBuilder();
        var instanciateBuilder = new StringBuilder();
        var instanciateT1Builder = new StringBuilder();

        foreach (var type in enumerations.Distinct(SymbolEqualityComparer.Default)
                     .Cast<INamedTypeSymbol>()
                     .Where(type => type != null)) {
            context.CancellationToken.ThrowIfCancellationRequested();

            var fqdn = Helper.MakeFullyQualifiedTypeName(type);

            checkBuilder.AppendLine($@"            case ""{fqdn}"":");

            if (type.IsGenericType) {
                // instanciateT1Builder.AppendLine($@"            ""{fqdn}"" => new {fqdn}(deserializer, context),");
            } else {
                instanciateBuilder.AppendLine($@"            ""{fqdn}"" => new {fqdn}(deserializer, context),");
            }
        }

        var code = @$"// <auto-generated />

using Duck.Serialization;
using Duck.Serialization.Exception;

namespace Generated.Serializer;

public class Instanciator : IInstanciator
{{
    public bool CanInstanciate(string typeName)
    {{
        switch(typeName) {{
{checkBuilder}
                return true;
        }}

        return false;
    }}

    public object Instanciate(string typeName, IDeserializer deserializer, IDeserializationContext context)
    {{
        return typeName switch {{
{instanciateBuilder}
            _ => default
        }};
    }}

    public object Instanciate<T>(string typeName, IDeserializer deserializer, IDeserializationContext context)
        where T : struct
    {{
        return typeName switch {{
{instanciateT1Builder}
            _ => default
        }};
    }}
}}
";


        context.AddSource($"Instanciator.Generated.cs", code);
    }

    private static bool IsSerializable(IFieldSymbol symbol)
    {
        if (symbol.Type.IsValueType) {
            return true;
        }

        foreach (var data in symbol.Type.GetAttributes()) {
            if (data.AttributeClass?.Name is "AutoSerializable" or "AutoSerializableAttribute") {
                return true;
            }
        }

        foreach (var typeSymbol in symbol.Type.AllInterfaces) {
            if (typeSymbol.Name == "ISerializable" && typeSymbol.ContainingNamespace.Name == "Duck.Serialization") {
                return true;
            }
        }

        return false;
    }

    private static ITypeSymbol? ResolveTypeOrNull(
        GeneratorSyntaxContext context,
        CancellationToken cancellationToken)
    {
        var attributeSyntax = (AttributeSyntax)context.Node;

        if (attributeSyntax.Parent?.Parent is not ClassDeclarationSyntax
            && attributeSyntax.Parent?.Parent is not StructDeclarationSyntax) {
            return null;
        }

        return context.SemanticModel.GetDeclaredSymbol(attributeSyntax.Parent?.Parent) as ITypeSymbol;
    }

    private static bool IsInterestingEnum(
        SyntaxNode syntaxNode,
        CancellationToken cancellationToken)
    {
        if (syntaxNode is not AttributeSyntax attribute)
            return false;

        var name = ExtractName(attribute.Name);

        return name is "AutoSerializable" or "AutoSerializableAttribute";
    }

    private static string? ExtractName(NameSyntax? name)
    {
        return name switch {
            SimpleNameSyntax ins => ins.Identifier.Text,
            QualifiedNameSyntax qns => qns.Right.Identifier.Text,
            _ => null
        };
    }
}
