using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Duck.SerializationGenerators;

[Generator]
public class SerializerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var types = context.SyntaxProvider
            .CreateSyntaxProvider(IsOfInterestToSyntaxProvider, TransformTypeForSyntaxProvider) 
            .Where(type => type is not null)
            .Collect();

        context.RegisterSourceOutput(types, Generate);
    }

    private static void Generate(SourceProductionContext context, ImmutableArray<ITypeSymbol?> types)
    {
        if (types.IsDefaultOrEmpty) {
            return;
        }

        foreach (var type in types.Distinct(SymbolEqualityComparer.Default)
                     .Cast<INamedTypeSymbol>()
                     .Where(type => type is not null)) {
            context.CancellationToken.ThrowIfCancellationRequested();

            GenerateStandaloneSerializer(context, type);
            // GeneratePartialSerializer(context, type);
        }
    }

    private static void GenerateStandaloneSerializer(SourceProductionContext context, INamedTypeSymbol type)
    {
        var typeNamespace = type.ContainingNamespace.IsGlobalNamespace ? null : $"{type.ContainingNamespace}.";
        var typeName = type.Name;
        var fileName = $"{typeNamespace}{typeName}Serializer.Generated.cs";
        var code = GenerateStandaloneSerializerCode(type);

        context.AddSource(fileName, CSharpSyntaxTree.ParseText(code).GetRoot().NormalizeWhitespace().ToFullString());
    }

    private static void GeneratePartialSerializer(SourceProductionContext context, INamedTypeSymbol type)
    {
        var typeNamespace = type.ContainingNamespace.IsGlobalNamespace ? null : $"{type.ContainingNamespace}.";
        var typeName = type.Name;
        var fileName = $"{typeNamespace}{typeName}.Generated.cs";
        var code = GeneratePartialSerializerCode(type);

        context.AddSource(fileName, CSharpSyntaxTree.ParseText(code).GetRoot().NormalizeWhitespace().ToFullString());
    }

    private static string GenerateStandaloneSerializerCode(INamedTypeSymbol type)
    {
        var serializerTypeName = type.Name + "Serializer";
        var serializeMethodImplementation = GenerateSerializerMethod(type);
        var deserializeMethodImplementation = GenerateDeserializerMethod(type);

        return
            $$"""
              // <auto-generated />

              using Duck.Serialization;
              using Duck.Serialization.Exception;

              {{(!type.ContainingNamespace.IsGlobalNamespace ? $"namespace {type.ContainingNamespace} {{" : "")}}
                  public static class {{serializerTypeName}}
                  {
                      {{serializeMethodImplementation}}
                      {{deserializeMethodImplementation}}
                  }
              {{(!type.ContainingNamespace.IsGlobalNamespace ? "}" : "")}}
              """;
    }

    private static string GeneratePartialSerializerCode(INamedTypeSymbol type)
    {
        var sb = new StringBuilder();

        var serializerTypeName = type.Name + "Serializer";
        var partialTypeName = type.Name;

        var template =
            $$"""
              // <auto-generated />

              using Duck.Serialization;
              using Duck.Serialization.Exception;

              {{(!type.ContainingNamespace.IsGlobalNamespace ? $"namespace {type.ContainingNamespace} {{" : "")}}
                  public partial struct {{partialTypeName}}
                  {
                      public void Serialize(IGraphSerializer serializer, ISerializationContext context)
                      {
                        {{serializerTypeName}}.Serialize(in this, serializer, context);
                      }
                  }
              {{(!type.ContainingNamespace.IsGlobalNamespace ? "}" : "")}}
              """;

        sb.Append(template);

        return sb.ToString();
    }

    private static string GenerateSerializerMethod(INamedTypeSymbol type)
    {
        var typeName = Util.MakeTypeName(type);
        var genericParameters = Util.MakeGenericParameterString(type, true);
        var genericConstraints = Util.MakeGenericConstraintString(type, true);
        var sb = new StringBuilder();

        foreach (var member in type.GetMembers()) {
            if (member is not IFieldSymbol fieldSymbol
                || fieldSymbol.Kind != SymbolKind.Field
                || fieldSymbol.Type is not INamedTypeSymbol) {
                continue;
            }

            if (!Util.IsFieldSerializable(fieldSymbol)) {
                continue;
            }

            var symbolName = fieldSymbol.AssociatedSymbol?.Name ?? fieldSymbol.Name;

            if (Util.IsSupportedContainerType(fieldSymbol.Type)) {
                sb.AppendLine($@"serializer.Write(""{symbolName}"", value.{symbolName}.ToArray(), ""{fieldSymbol.Type.ContainingNamespace}.{fieldSymbol.Type.Name}"");");
            } else {
                sb.AppendLine($@"serializer.Write(""{symbolName}"", value.{symbolName});");
            }
        }

        return $$"""
                 public static void Serialize{{genericParameters}}(in {{typeName}} value, IGraphSerializer serializer, ISerializationContext context) {{genericConstraints}}
                 {
                    {{sb}}
                 }
                 """;
    }

    private static string GenerateDeserializerMethod(INamedTypeSymbol type)
    {
        var typeName = Util.MakeTypeName(type);
        var genericParameters = Util.MakeGenericParameterString(type, true);
        var genericConstraints = Util.MakeGenericConstraintString(type, true);
        var deserializeMemberBuilder = GenerateMemberDeserializerList(type);
        var addToContextStr = "";

        if (!type.IsValueType) {
            addToContextStr = """
                              if (context.ObjectId != null) {
                                  context.AddObject(context.ObjectId.Value, ret);
                              }
                              """;
        }

        return $$"""
                 public static {{typeName}} Deserialize{{genericParameters}}(IDeserializer deserializer, IDeserializationContext context) {{genericConstraints}}
                 {
                     var ret = new {{typeName}}();
                 
                     {{addToContextStr}}
                 
                     foreach (var entry in deserializer.Index) {
                         switch(entry.Name) {
                             {{deserializeMemberBuilder}}
                         }
                     }
                 
                     return ret;
                 }
                 """;
    }
    private static string GenerateMemberDeserializerList(INamedTypeSymbol type)
    {
        var deserializeMemberBuilder = new StringBuilder();

        foreach (var member in type.GetMembers()) {
            if (member is not IFieldSymbol fieldSymbol) {
                continue;
            }

            if (fieldSymbol.Kind != SymbolKind.Field || !Util.IsFieldSerializable(fieldSymbol)) {
                continue;
            }

            var symbolName = fieldSymbol.AssociatedSymbol?.Name ?? fieldSymbol.Name;
            var fieldTypeSymbol = fieldSymbol.Type as INamedTypeSymbol;

            if (fieldTypeSymbol == null) {
                continue;
            }

            if (Util.IsSupportedContainerType(fieldSymbol.Type)) {
                deserializeMemberBuilder.AppendLine($@"case ""{symbolName}"":
                     ret.{symbolName} = deserializer.ReadObjectList<{fieldSymbol.Type.ToDisplayString()}, {fieldTypeSymbol?.TypeArguments[0].ToDisplayString()}>(
                         (objectDeserializer, objectContext, entry) => Instanciator.Create<{fieldTypeSymbol?.TypeArguments[0].Name}>({(fieldTypeSymbol.TypeArguments[0].IsAbstract ? "entry.ExplicitType" : $@"""{fieldSymbol.Type.ToDisplayString()}""")}, objectDeserializer, objectContext),
                         ""{fieldSymbol.Type.ContainingNamespace}.{fieldSymbol.Type.Name}"",
                         entry.OffsetStart
                     );
                     break;");
            } else {
                var doesImplementISerializable =
                    fieldSymbol.Type.AllInterfaces.Any(symbol => symbol.Name == "ISerializable") || fieldSymbol.Type
                        .GetAttributes().Any(data => data.AttributeClass.Name == "DuckSerializable");
                var typeList = new List<string>();

                typeList.Add(fieldSymbol.Type.ToDisplayString());

                if (fieldTypeSymbol.IsGenericType) {
                    typeList.Add(Util.MakeGenericArgumentString(fieldTypeSymbol));
                }

                var methodName = Util.GetPrimitiveSerializerMethodName(fieldSymbol);
                // var methodName = "X";

                if (doesImplementISerializable) {
                    deserializeMemberBuilder.AppendLine($@"case ""{symbolName}"":
                    {symbolName} = deserializer.ReadObjectReference<{fieldSymbol.Type.ToDisplayString()}>(
                        (objectDeserializer, objectContext, objectEntry) => Instanciator.Create<{String.Join(",", typeList)}>({(fieldSymbol.Type.IsAbstract ? "objectEntry.ExplicitType" : $@"""{fieldSymbol.Type.ToDisplayString()}""")}, objectDeserializer, objectContext),
                        entry
                    );
                    break;");
                } else {
                    if (fieldTypeSymbol.IsGenericType) {
                        var argString = Util.MakeGenericArgumentString(fieldTypeSymbol);
                        deserializeMemberBuilder.AppendLine(
                            $@"case ""{symbolName}"": ret.{symbolName} = deserializer.{methodName}<{argString}>(entry.OffsetStart); break;");
                    } else {
                        deserializeMemberBuilder.AppendLine(
                            $@"case ""{symbolName}"": ret.{symbolName} = deserializer.{methodName}(entry.OffsetStart); break;");
                    }
                }
            }
        }

        return deserializeMemberBuilder.ToString();
    }

    private static ITypeSymbol? TransformTypeForSyntaxProvider(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var attributeSyntax = (AttributeSyntax)context.Node;

        if (attributeSyntax.Parent?.Parent is not ClassDeclarationSyntax
            && attributeSyntax.Parent?.Parent is not StructDeclarationSyntax
            && attributeSyntax.Parent?.Parent is not InterfaceDeclarationSyntax) {
            return null;
        }

        return context.SemanticModel.GetDeclaredSymbol(attributeSyntax.Parent.Parent) as ITypeSymbol;
    }

    private static bool IsOfInterestToSyntaxProvider(SyntaxNode syntaxNode,
        CancellationToken cancellationToken)
    {
        if (syntaxNode is not AttributeSyntax attribute) {
            return false;
        }

        var name = attribute.Name switch {
            SimpleNameSyntax ins => ins.Identifier.Text,
            QualifiedNameSyntax qns => qns.Right.Identifier.Text,
            _ => null
        };

        return Util.IsAutoSerializableAttributeName(name ?? "");
    }
}