using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Duck.SerializationGenerators;

[Generator]
public class SerializerMethodGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var methodDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(IsOfInterestToSyntaxProvider, TransformTypeForSyntaxProvider)
            .Where(type => type is not null)
            .Collect();

        context.RegisterSourceOutput(methodDeclarations, Generate);
    }

    private static void Generate(SourceProductionContext context, ImmutableArray<IMethodSymbol?> methodDeclarations)
    {
        if (methodDeclarations.IsDefaultOrEmpty) {
            return;
        }

        var methodsGroupedByContainer = new Dictionary<INamedTypeSymbol, List<IMethodSymbol>>(SymbolEqualityComparer.Default);

        foreach (var methodSymbol in methodDeclarations.Distinct(SymbolEqualityComparer.Default)
                     .Cast<IMethodSymbol>()
                     .Where(type => type is not null)) {
            context.CancellationToken.ThrowIfCancellationRequested();

            if (!methodSymbol.IsPartialDefinition) {
                continue;
            }
            
            var containerType = methodSymbol.ContainingType;

            if (!methodsGroupedByContainer.ContainsKey(containerType)) {
                methodsGroupedByContainer.Add(containerType, new List<IMethodSymbol>());
            }
            
            methodsGroupedByContainer[containerType].Add(methodSymbol);
        }
        
        foreach (var kvp in methodsGroupedByContainer) {
            GenerateSerializer(context, kvp.Key, kvp.Value.ToImmutableArray());
        }
    }

    private static void GenerateSerializer(SourceProductionContext context, INamedTypeSymbol containingSymbol, ImmutableArray<IMethodSymbol> methodSymbols)
    {
        var typeName = containingSymbol.ToDisplayString();
        var fileName = $"{typeName}.SerializerMethods.cs";
        
        var methodCode = new StringBuilder();
        
        foreach (var methodSymbol in methodSymbols) {
            methodCode.Append(GenerateSerializerMethod(methodSymbol));
        }

        var code =
            $$"""
              // <auto-generated />

              using Duck.Serialization;
              using Duck.Serialization.Exception;

              {{(!containingSymbol.ContainingNamespace.IsGlobalNamespace ? $"namespace {containingSymbol.ContainingNamespace} {{" : "")}}
                  public partial class {{containingSymbol.Name}}
                  {
                    {{methodCode}}
                  }
              {{(!containingSymbol.ContainingNamespace.IsGlobalNamespace ? "}" : "")}}
              """;
        
        context.AddSource(fileName, CSharpSyntaxTree.ParseText(code).GetRoot().NormalizeWhitespace().ToFullString());
    }

    private static string GenerateSerializerMethod(IMethodSymbol method)
    {
       /* var typeName = Util.MakeTypeName(type);
        var genericParameters = Util.MakeGenericParameterString(type, true);
        var genericConstraints = Util.MakeGenericConstraintString(type, true);
        var sb = new StringBuilder();

        foreach (var member in type.GetMembers()) {
            if (member is not IFieldSymbol fieldSymbol
                || fieldSymbol.Kind != SymbolKind.Field
                || fieldSymbol.Type is not INamedTypeSymbol) {
                continue;
            }

            if (!Util.IsFieldSerializable(fieldSymbol)) {
                continue;
            }

            var symbolName = fieldSymbol.AssociatedSymbol?.Name ?? fieldSymbol.Name;

            if (Util.IsSupportedContainerType(fieldSymbol.Type)) {
                sb.AppendLine($@"serializer.Write(""{symbolName}"", value.{symbolName}.ToArray(), ""{fieldSymbol.Type.ContainingNamespace}.{fieldSymbol.Type.Name}"");");
            } else {
                sb.AppendLine($@"serializer.Write(""{symbolName}"", value.{symbolName});");
            }
        }*/

       var parameters = new List<string>();
       method.Parameters.ToList().ForEach(parameter => parameters.Add($"{(parameter.RefKind == RefKind.In ? "in" : "")} {parameter.Type.ToDisplayString()} {parameter.Name}"));

        return $$"""
                 public partial {{method.ReturnType.ToDisplayString()}} {{method.Name}}({{string.Join(",", parameters)}})
                 {
                    ThrowIfSealed();
                 
                    var offsetStart = _primitiveSerializer.Position;
                 
                    _primitiveSerializer.Write(value.Count);
                 
                    foreach (var e in value) {
                         _primitiveSerializer.Write(e);
                    }
                 
                    PushIndex(name, DataType.GenericList, offsetStart, _primitiveSerializer.Position);
                 }
                 """;
    }

    private static IMethodSymbol? TransformTypeForSyntaxProvider(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var declarationSyntax = (MethodDeclarationSyntax)context.Node;

        // loop through all the attributes on the method
        foreach (var attributeListSyntax in declarationSyntax.AttributeLists) {
            foreach (var attributeSyntax in attributeListSyntax.Attributes) {
                if (ModelExtensions.GetSymbolInfo(context.SemanticModel, attributeSyntax).Symbol is not IMethodSymbol attributeSymbol) {
                    continue;
                }

                var attributeContainingTypeSymbol = attributeSymbol.ContainingType;
                var fullName = Util.GetNameWithoutGenericArity(attributeContainingTypeSymbol.ToDisplayString());

                if (fullName != "Duck.Serialization.GenerateListSerializerAttribute") {
                    continue;
                }

                return context.SemanticModel.GetDeclaredSymbol(declarationSyntax);
            }
        }

        return null;
    }

    private static bool IsOfInterestToSyntaxProvider(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        return syntaxNode is MethodDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    class Comparer : IEqualityComparer<MethodDeclarationSyntax>
    {
        public static readonly Comparer Instance = new Comparer();

        public bool Equals(MethodDeclarationSyntax x, MethodDeclarationSyntax y)
        {
            return x.Equals(y);
        }

        public int GetHashCode(MethodDeclarationSyntax obj)
        {
            return obj.GetHashCode();
        }
    }
}
